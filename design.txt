cpu
    configuration
    devices
        list:
            touchscreen
            timer
        can register interrupts and memory space
    interrupt
        default interrupt vector
            divide by zero
            invalid opcode
            space fault: when cpu access unmapped memory
        devices can't fire interrupts when cpu is in interrupt handler
        interrupt handler is responsible of PC on interrupt handler exit
    instruction set
        jumps are always conditionnal
        x is index 1
        y is index 2
        s is reg slice
            T reg.b
            0 reg.t
            1 reg.w
        v is inline imm (inimm (size))
        00000000_: no param
            0 nop
            intret
        00000001_: 1 imm.b/w
            callabs imm.w
            callrel imm.b
        000001_xx: 1 index
            0 not reg
            T push reg
            1 pop reg
        00001_vxx: 1 inimm (1), 1 index, 1 imm.b/w
            jumpabs flagvalue flagindex imm.w
            jumprel flagvalue flagindex imm.b
        0000T_sxx: 1 imm.b/w, 1 index, 1 slice
            0 set reg.t/b/w, imm.b/w
        00T_syyxx: 2 index, 1 slice
            load reg.b/t/w, [reg].b/w
            store [reg].b/w, reg.b/t/w
        01___yyxx: 2 index
            mov reg, reg
            add reg, reg
            sub reg, reg
            mul reg, reg
            div reg, reg
            mod reg, reg
            add_fz reg, reg
            sub_fz reg, reg
            test reg, reg:
                does all comparaison and put result in flag reg
            and reg, reg
            or reg, reg
            xor reg, reg
        ___vvvvxx: 1 index, 1 inimm (4), can't start with 00 or 01
            add reg, inimm
            sub reg, inimm
            mul reg, inimm
            div reg, inimm
            mod reg, inimm
            add_fz reg, inimm
            sub_fz reg, inimm
            test reg, inimm
            test inimm, reg
                does all comparaison and put result in flag reg
        not defined yet
            in imm
            out imm
            setup
    memory: harvard/neumann architecture mix
        memory access is made through pointers and doesn't crossover between memspace
        a pointer is word wide
        each pointer use it's upper byte to address a specific memory space
        the 2 lower byte is a 2 bytes offset in this memory space
        code space: 0000000
            program: positive offset
            interrupt handler and init: negative offset
        general memory space: 0000001
            general use: positive offset
            stack: negative offset
    registers
        9 registers: 1 word wide
            program pointer
            stack pointer
            flag register: each trit correspond to one comp
                diff, T if lesser, 0 if equal, 1 if greater
                diff_fz, T if lesser, 0 if equal, 1 if greater
                carry
                zero
            6 general purpose
        reg.t is the most significant byte (top)
        reg.b is the least significant byte (bottom)
        reg.w is the whole value (word) <- default
    trit: 1 balanced ternary value
    byte: 9 trits little-endian
    word: 2 bytes little-endian
    https://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics
